<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æœ±è¿ªä¸å°¼å…‹çš„æ£‹å±€</title>
    
    <!-- iOS PWA Fullscreen Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-title" content="ZootopiaChess">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* --- å…¨å±€æ ·å¼ --- */
        body {
            font-family: 'Nunito', 'Noto Sans SC', system-ui, sans-serif;
            background: radial-gradient(circle at 50% 10%, #2b324d 0%, #151925 100%);
            color: #e2e8f0;
            overscroll-behavior: none;
            -webkit-user-select: none;
            user-select: none;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            touch-action: manipulation;
        }

        /* 3D ç»ç’ƒæ‹Ÿæ€å¡ç‰‡ */
        .glass-panel {
            background: rgba(30, 41, 59, 0.75);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .btn-game {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        .btn-game:active { transform: scale(0.95); }

        /* --- äº”å­æ£‹æ£‹ç›˜ (äº¤å‰ç‚¹é€»è¾‘é‡æ„) --- */
        .gobang-board {
            /* å¢å¤§å°ºå¯¸ï¼šä½¿ç”¨ 98% çš„çŸ­è¾¹é•¿åº¦ï¼Œæœ€å¤§é™åˆ¶æ”¾å®½ */
            width: 96vmin;
            height: 96vmin;
            /* iPad Pro ç«–å±å®½åº¦è¾ƒå¤§ï¼Œé™åˆ¶ä¸€ä¸‹æœ€å¤§ç‰©ç†å°ºå¯¸ä»¥å…è¿‡äºå¤¸å¼ ï¼Œä½†æ¯”ä¹‹å‰å¤§ */
            max-width: 900px; 
            max-height: 900px;
            
            background-color: #e6b87d;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                inset 0 0 60px rgba(66, 33, 10, 0.2);
            border-radius: 4px;
            /* å¤–è¾¹æ¡† */
            border: 6px solid #6b4423; 
            
            position: relative;
            /* Padding å‡å°‘ï¼Œè®©æ ¼å­æ’‘æ»¡ */
            padding: 4px; 
            
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
        }

        /* æ ¸å¿ƒé€»è¾‘ï¼šæ¯ä¸ª .gobang-cell ä»£è¡¨ä¸€ä¸ªäº¤å‰ç‚¹åŒºåŸŸã€‚
           åˆ©ç”¨èƒŒæ™¯æ¸å˜åœ¨æ¯ä¸ªæ ¼å­çš„æ­£ä¸­å¿ƒç”»åå­—çº¿ã€‚
        */
        .gobang-cell {
            position: relative;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            /* ç»˜åˆ¶åå­—çº¿ */
            background-image: 
                linear-gradient(to right, transparent calc(50% - 1px), #5c3a1e calc(50% - 1px), #5c3a1e calc(50% + 1px), transparent calc(50% + 1px)),
                linear-gradient(to bottom, transparent calc(50% - 1px), #5c3a1e calc(50% - 1px), #5c3a1e calc(50% + 1px), transparent calc(50% + 1px));
        }

        /* äº”å­æ£‹å­ - ç¡®ä¿å®Œå…¨è¦†ç›–äº¤å‰ç‚¹ä¸­å¿ƒ */
        .gobang-piece {
            width: 92%;
            height: 92%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem; /* ç¨å¾®è°ƒå¤§ Emoji */
            position: relative;
            z-index: 20; 
            box-shadow: 3px 5px 8px rgba(0,0,0,0.4);
            transition: transform 0.15s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .piece-white {
            background: radial-gradient(circle at 30% 30%, #ffffff, #cbd5e1);
            color: #333;
        }
        .piece-black {
            background: radial-gradient(circle at 30% 30%, #475569, #0f172a);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.15);
        }

        /* æœ€åä¸€ä¸ªè½å­æ ‡è®° */
        .last-move-marker::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background: rgba(255, 0, 0, 0.6);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 4px rgba(255,0,0,0.8);
        }

        /* --- å›½é™…è±¡æ£‹æ£‹ç›˜ --- */
        .chess-board {
            width: 96vmin;
            height: 96vmin;
            max-width: 900px;
            max-height: 900px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 6px solid #334155;
            border-radius: 4px;
            box-shadow: 0 25px 60px -12px rgba(0, 0, 0, 0.7);
        }
        .chess-square {
            position: relative; /* ä¸ºäº†å®šä½æç¤ºç‚¹ */
        }
        .chess-square.white { background-color: #e2e8f0; color: #1e293b; }
        .chess-square.black { background-color: #64748b; color: #f1f5f9; }
        
        .chess-square.selected {
            background-color: rgba(244, 63, 94, 0.7) !important;
        }
        .chess-square.last-move {
            background-color: rgba(250, 204, 21, 0.5) !important;
        }

        /* æç¤ºç‚¹æ ·å¼ */
        .hint-dot {
            position: absolute;
            width: 25%;
            height: 25%;
            background-color: rgba(34, 197, 94, 0.7); /* Green */
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 15;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ°æ ¼å­ */
            animation: pulseHint 1.5s infinite;
        }
        /* åƒå­æç¤º (åœ†åœˆ) */
        .hint-capture {
            position: absolute;
            width: 80%;
            height: 80%;
            border: 4px solid rgba(239, 68, 68, 0.6); /* Red ring */
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 15;
            pointer-events: none;
        }

        @keyframes pulseHint {
            0% { transform: translate(-50%, -50%) scale(0.9); opacity: 0.7; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0.9); opacity: 0.7; }
        }

        .chess-piece {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(2rem, 8vmin, 4.5rem); /* åŠ¨æ€å­—ä½“å¤§å° */
            cursor: pointer;
            z-index: 20;
            filter: drop-shadow(0px 4px 2px rgba(0,0,0,0.3));
            transition: transform 0.2s;
        }
        .chess-piece.white-side { color: #f8fafc; text-shadow: 0 2px 0 #94a3b8; }
        .chess-piece.black-side { color: #1e293b; text-shadow: 0 2px 0 #000; }
        .chess-piece:active { transform: scale(1.15); }

        .hidden { display: none !important; }

        /* å¼¹çª—åŠ¨ç”» */
        @keyframes popIn {
            0% { transform: scale(0.9); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .modal-content {
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .safe-area-top { padding-top: env(safe-area-inset-top); }
        .safe-area-bottom { padding-bottom: env(safe-area-inset-bottom); }
    </style>
</head>
<body class="flex flex-col items-center safe-area-top safe-area-bottom">

    <!-- ä¸»èœå• -->
    <div id="main-menu" class="w-full h-full flex flex-col items-center justify-center p-6 space-y-8 z-10">
        <div class="text-center space-y-3">
            <h1 class="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-teal-200 to-cyan-400 tracking-tight drop-shadow-sm">
                æ£‹ä¹æ— ç©·
            </h1>
            <p class="text-xl text-slate-400 font-bold">Judy & Nick çš„å¯¹å¼ˆæ—¶å…‰</p>
        </div>

        <div class="glass-panel p-8 w-full max-w-md space-y-6">
            <div class="text-center mb-6 flex justify-center gap-6">
                <span class="text-6xl filter drop-shadow-lg">ğŸ°</span> 
                <span class="text-4xl flex items-center text-slate-500 font-black">VS</span>
                <span class="text-6xl filter drop-shadow-lg">ğŸ¦Š</span>
            </div>
            
            <button onclick="setupGame('gobang')" class="btn-game w-full bg-gradient-to-r from-emerald-500 to-teal-500 text-white py-4 rounded-xl text-xl font-bold shadow-lg shadow-emerald-500/20 flex items-center justify-center space-x-3">
                <span class="text-2xl">âš«âšª</span>
                <span>äº”å­æ£‹ (Gobang)</span>
            </button>
            
            <button onclick="setupGame('chess')" class="btn-game w-full bg-gradient-to-r from-violet-500 to-fuchsia-500 text-white py-4 rounded-xl text-xl font-bold shadow-lg shadow-violet-500/20 flex items-center justify-center space-x-3">
                <span class="text-2xl">â™Ÿï¸</span>
                <span>å›½é™…è±¡æ£‹ (Chess)</span>
            </button>
        </div>
    </div>

    <!-- æ¸¸æˆè®¾ç½®ç•Œé¢ -->
    <div id="setup-screen" class="hidden w-full h-full flex flex-col items-center justify-center p-6 z-10">
        <div class="glass-panel p-8 w-full max-w-md space-y-6">
            <h2 id="setup-title" class="text-3xl font-bold text-center text-white">æ¸¸æˆè®¾ç½®</h2>
            
            <div class="space-y-3">
                <label class="block text-slate-300 font-bold text-sm uppercase tracking-wide">å¯¹æˆ˜æ¨¡å¼</label>
                <div class="flex space-x-4">
                    <button id="mode-pve" onclick="selectMode('pve')" class="flex-1 py-4 rounded-xl border border-teal-500 bg-teal-500/20 text-teal-300 font-bold transition-all">
                        äººæœº (ğŸ°vsğŸ¤–)
                    </button>
                    <button id="mode-pvp" onclick="selectMode('pvp')" class="flex-1 py-4 rounded-xl border border-slate-600 bg-slate-700/30 text-slate-400 font-bold transition-all">
                        åŒäºº (ğŸ°vsğŸ¦Š)
                    </button>
                </div>
            </div>

            <div id="difficulty-selector" class="space-y-3">
                <label class="block text-slate-300 font-bold text-sm uppercase tracking-wide">AI éš¾åº¦</label>
                <select id="difficulty" class="w-full p-4 rounded-xl bg-slate-700/50 border border-slate-600 text-white text-lg outline-none focus:border-teal-500">
                    <option value="easy">ç®€å• (å®ä¹ ç”Ÿ)</option>
                    <option value="medium" selected>ä¸­ç­‰ (è­¦å‘˜)</option>
                    <option value="hard">å›°éš¾ (å±€é•¿)</option>
                </select>
            </div>

            <div class="pt-6 flex space-x-4">
                <button onclick="goBack('main')" class="flex-1 py-3 rounded-xl bg-slate-700 text-slate-300 font-bold">è¿”å›</button>
                <button onclick="startDicePhase()" class="flex-1 py-3 rounded-xl bg-gradient-to-r from-cyan-500 to-blue-500 text-white font-bold shadow-lg shadow-cyan-500/20">å¼€å§‹æ¸¸æˆ</button>
            </div>
        </div>
    </div>

    <!-- æ·éª°å­å¼¹çª— -->
    <div id="dice-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
        <div class="modal-content glass-panel p-8 w-80 text-center space-y-6">
            <h3 class="text-xl font-bold text-white">æ·éª°å­å®šå…ˆæ‰‹</h3>
            <div class="flex justify-around items-center">
                <div class="text-center">
                    <div class="text-4xl mb-2">ğŸ°</div>
                    <div id="dice-p1" class="text-3xl font-mono font-bold text-teal-400">-</div>
                </div>
                <div class="text-slate-500 font-bold">VS</div>
                <div class="text-center">
                    <div class="text-4xl mb-2" id="dice-p2-icon">ğŸ¤–</div>
                    <div id="dice-p2" class="text-3xl font-mono font-bold text-rose-400">-</div>
                </div>
            </div>
            <p id="dice-msg" class="text-sm text-slate-400 h-6">å‡†å¤‡æ·éª°å­...</p>
            <button id="roll-btn" onclick="rollDiceAnim()" class="w-full py-3 bg-indigo-600 text-white rounded-xl font-bold shadow-lg">æ·éª°å­</button>
        </div>
    </div>

    <!-- æ¸¸æˆä¸»ç•Œé¢ -->
    <div id="game-screen" class="hidden w-full h-full flex flex-col items-center relative">
        <!-- é¡¶éƒ¨ä¿¡æ¯æ  -->
        <div class="w-full flex justify-between items-center px-4 py-3 glass-panel rounded-none border-t-0 border-x-0 z-20 shrink-0">
            <button onclick="confirmExit()" class="text-sm bg-slate-700 hover:bg-red-500/20 hover:text-red-400 px-4 py-2 rounded-lg font-bold text-slate-300 transition-colors">é€€å‡º</button>
            
            <div class="flex items-center space-x-6">
                <!-- P1 Info -->
                <div id="p1-indicator" class="flex flex-col items-center transition-opacity duration-300 opacity-100">
                    <div class="w-10 h-10 rounded-full bg-white text-black flex items-center justify-center text-xl shadow-lg border-2 border-emerald-400 relative">
                        ğŸ°
                        <div id="p1-turn-dot" class="absolute -bottom-1 -right-1 w-3 h-3 bg-emerald-500 rounded-full hidden"></div>
                    </div>
                </div>
                
                <!-- Score/VS -->
                <div class="flex flex-col items-center">
                    <div class="text-slate-500 font-black text-xs tracking-widest">VS</div>
                    <div id="timer" class="text-xs text-slate-400 font-mono mt-1">00:00</div>
                </div>
                
                <!-- P2 Info -->
                <div id="p2-indicator" class="flex flex-col items-center transition-opacity duration-300 opacity-50">
                    <div id="p2-indicator-bg" class="w-10 h-10 rounded-full bg-slate-700 text-white flex items-center justify-center text-xl shadow-lg border-2 border-transparent relative">
                        <span id="p2-avatar-game">ğŸ¤–</span>
                        <div id="p2-turn-dot" class="absolute -bottom-1 -right-1 w-3 h-3 bg-emerald-500 rounded-full hidden"></div>
                    </div>
                </div>
            </div>

            <div class="flex gap-2">
                <!-- æç¤ºå¼€å…³ (ä»…å›½é™…è±¡æ£‹æ˜¾ç¤º) -->
                <button id="hint-toggle-btn" onclick="toggleHints()" class="hidden text-sm bg-slate-700 hover:bg-yellow-500/20 hover:text-yellow-300 px-3 py-2 rounded-lg font-bold text-slate-300 transition-colors">
                    ğŸ’¡
                </button>
                <button onclick="undoMove()" class="text-sm bg-slate-700 hover:bg-slate-600 px-3 py-2 rounded-lg font-bold text-amber-400 transition-colors">
                    â†©ï¸
                </button>
                <button onclick="restartGame()" class="text-sm bg-slate-700 hover:bg-indigo-600/30 hover:text-indigo-300 px-3 py-2 rounded-lg font-bold text-slate-300 transition-colors">
                    â†»
                </button>
            </div>
        </div>

        <!-- æ¸¸æˆåŒºåŸŸ (å±…ä¸­, æœ€å¤§åŒ–) -->
        <div class="flex-1 w-full flex items-center justify-center p-1 overflow-hidden">
            <div id="board-container" class="relative transition-all duration-300">
                <!-- æ£‹ç›˜å°†é€šè¿‡ JS åŠ¨æ€æ³¨å…¥ -->
            </div>
        </div>

        <!-- åº•éƒ¨çŠ¶æ€æ  -->
        <div class="w-full p-4 pb-8 text-center glass-panel rounded-none border-b-0 border-x-0 shrink-0">
            <span id="game-status" class="text-emerald-400 font-bold text-lg animate-pulse">
                ç­‰å¾…å¼€å§‹...
            </span>
        </div>
    </div>

    <!-- ç»“ç®—å¼¹çª— -->
    <div id="result-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
        <div class="modal-content glass-panel p-8 w-80 text-center space-y-6 border border-white/20">
            <div class="text-7xl mb-4" id="winner-icon">ğŸ†</div>
            <h2 class="text-3xl font-black text-white" id="winner-text">æ¸¸æˆç»“æŸ</h2>
            <p class="text-slate-300" id="winner-sub">èƒœåˆ©å±äºæœ±è¿ªï¼</p>
            <div class="flex space-x-3">
                <button onclick="confirmExit()" class="flex-1 py-3 bg-slate-700 text-slate-300 rounded-xl font-bold">ä¸»é¡µ</button>
                <button onclick="startDicePhase()" class="flex-1 py-3 bg-emerald-600 text-white rounded-xl font-bold shadow-lg shadow-emerald-500/30">å†æ¥ä¸€å±€</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * æ¸¸æˆçŠ¶æ€ç®¡ç†
         */
        const state = {
            gameType: null, // 'gobang' or 'chess'
            mode: 'pve',    // 'pve' or 'pvp'
            difficulty: 'medium',
            currentPlayer: 1, // 1 = P1 (Judy), 2 = P2 (Nick/AI)
            startPlayer: 1,   // Determined by dice
            board: [],
            history: [], // For Undo
            gameOver: false,
            aiThinking: false,
            timer: 0,
            timerInterval: null,
            showHints: false, // Chess hints toggle
            lastMove: null // Record last move {fx, fy, tx, ty} or {x, y}
        };

        const config = {
            gobangSize: 15,
            icons: {
                p1: 'ğŸ°',
                p2_human: 'ğŸ¦Š',
                p2_ai: 'ğŸ¤–'
            }
        };

        // --- æ ¸å¿ƒé€»è¾‘ ---

        function setupGame(type) {
            state.gameType = type;
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('setup-screen').classList.remove('hidden');
            document.getElementById('setup-title').innerText = type === 'gobang' ? 'äº”å­æ£‹è®¾ç½®' : 'å›½é™…è±¡æ£‹è®¾ç½®';
        }

        function selectMode(mode) {
            state.mode = mode;
            const btnPve = document.getElementById('mode-pve');
            const btnPvp = document.getElementById('mode-pvp');
            
            if(mode === 'pve') {
                btnPve.className = "flex-1 py-4 rounded-xl border border-teal-500 bg-teal-500/20 text-teal-300 font-bold transition-all";
                btnPvp.className = "flex-1 py-4 rounded-xl border border-slate-600 bg-slate-700/30 text-slate-400 font-bold transition-all";
            } else {
                btnPve.className = "flex-1 py-4 rounded-xl border border-slate-600 bg-slate-700/30 text-slate-400 font-bold transition-all";
                btnPvp.className = "flex-1 py-4 rounded-xl border border-teal-500 bg-teal-500/20 text-teal-300 font-bold transition-all";
            }

            const diffSelector = document.getElementById('difficulty-selector');
            if(mode === 'pvp') diffSelector.classList.add('hidden');
            else diffSelector.classList.remove('hidden');
        }

        function goBack(target) {
            if(target === 'main') {
                document.getElementById('setup-screen').classList.add('hidden');
                document.getElementById('main-menu').classList.remove('hidden');
            }
        }

        function startDicePhase() {
            state.difficulty = document.getElementById('difficulty').value;
            document.getElementById('result-modal').classList.add('hidden');
            document.getElementById('setup-screen').classList.add('hidden');
            document.getElementById('game-screen').classList.add('hidden');
            
            // Dice UI Reset
            document.getElementById('dice-modal').classList.remove('hidden');
            document.getElementById('roll-btn').classList.remove('hidden');
            document.getElementById('dice-p1').innerText = '-';
            document.getElementById('dice-p2').innerText = '-';
            document.getElementById('dice-msg').innerText = "ç‚¹æ•°å¤§çš„å…ˆè¡Œ";
            
            const p2Icon = state.mode === 'pve' ? config.icons.p2_ai : config.icons.p2_human;
            document.getElementById('dice-p2-icon').innerText = p2Icon;
        }

        function rollDiceAnim() {
            const btn = document.getElementById('roll-btn');
            btn.classList.add('hidden');
            const elP1 = document.getElementById('dice-p1');
            const elP2 = document.getElementById('dice-p2');
            const msg = document.getElementById('dice-msg');

            msg.innerText = "æ·éª°å­ä¸­...";
            
            let rolls = 0;
            const interval = setInterval(() => {
                elP1.innerText = Math.floor(Math.random()*6)+1;
                elP2.innerText = Math.floor(Math.random()*6)+1;
                rolls++;
                if(rolls > 10) {
                    clearInterval(interval);
                    finalizeDice();
                }
            }, 100);
        }

        function finalizeDice() {
            let d1 = Math.floor(Math.random()*6)+1;
            let d2 = Math.floor(Math.random()*6)+1;
            while(d1 === d2) { d2 = Math.floor(Math.random()*6)+1; }

            document.getElementById('dice-p1').innerText = d1;
            document.getElementById('dice-p2').innerText = d2;

            const winner = d1 > d2 ? 1 : 2;
            const p2Name = state.mode === 'pve' ? 'ç”µè„‘' : 'å°¼å…‹';
            const winnerName = winner === 1 ? 'æœ±è¿ª' : p2Name;

            document.getElementById('dice-msg').innerText = `${winnerName} å…ˆæ‰‹ï¼`;
            state.startPlayer = winner;

            setTimeout(() => {
                document.getElementById('dice-modal').classList.add('hidden');
                startGame();
            }, 1500);
        }

        function startGame() {
            document.getElementById('game-screen').classList.remove('hidden');
            const p2Icon = state.mode === 'pve' ? config.icons.p2_ai : config.icons.p2_human;
            document.getElementById('p2-avatar-game').innerText = p2Icon;
            
            // Toggle Hints button
            const hintBtn = document.getElementById('hint-toggle-btn');
            if(state.gameType === 'chess') {
                hintBtn.classList.remove('hidden');
            } else {
                hintBtn.classList.add('hidden');
            }
            state.showHints = false;
            updateHintButton();

            initBoard();
        }

        function toggleHints() {
            state.showHints = !state.showHints;
            updateHintButton();
            if(state.gameType === 'chess' && selectedSquare) {
                renderHints(selectedSquare.x, selectedSquare.y);
            }
        }

        function updateHintButton() {
            const btn = document.getElementById('hint-toggle-btn');
            if(state.showHints) {
                btn.classList.remove('bg-slate-700', 'text-slate-300');
                btn.classList.add('bg-yellow-500', 'text-white');
            } else {
                btn.classList.remove('bg-yellow-500', 'text-white');
                btn.classList.add('bg-slate-700', 'text-slate-300');
            }
        }

        function confirmExit() {
            if(state.timerInterval) clearInterval(state.timerInterval);
            document.getElementById('game-screen').classList.add('hidden');
            document.getElementById('result-modal').classList.add('hidden');
            document.getElementById('setup-screen').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');
            state.board = [];
            state.history = [];
            state.gameOver = false;
            state.lastMove = null;
        }

        function restartGame() {
            if(confirm("ç¡®å®šè¦é‡æ–°å¼€å§‹å—ï¼Ÿ")) {
                startDicePhase();
            }
        }

        function startTimer() {
            if(state.timerInterval) clearInterval(state.timerInterval);
            state.timer = 0;
            const el = document.getElementById('timer');
            state.timerInterval = setInterval(() => {
                state.timer++;
                let m = Math.floor(state.timer / 60).toString().padStart(2, '0');
                let s = (state.timer % 60).toString().padStart(2, '0');
                el.innerText = `${m}:${s}`;
            }, 1000);
        }

        function initBoard() {
            state.gameOver = false;
            state.currentPlayer = state.startPlayer; 
            state.aiThinking = false;
            state.history = []; 
            state.lastMove = null;
            const container = document.getElementById('board-container');
            container.innerHTML = '';
            
            startTimer();

            if(state.gameType === 'gobang') initGobang(container);
            else initChess(container);
            
            updateTurnIndicator();

            if(state.mode === 'pve' && state.currentPlayer === 2) {
                state.aiThinking = true;
                updateTurnIndicator();
                setTimeout(() => {
                    if(state.gameType === 'gobang') aiGobangMove();
                    else aiChessMove();
                }, 1000);
            }
        }

        function updateTurnIndicator() {
            const p1Ind = document.getElementById('p1-indicator');
            const p2Ind = document.getElementById('p2-indicator');
            const p1Dot = document.getElementById('p1-turn-dot');
            const p2Dot = document.getElementById('p2-turn-dot');
            const status = document.getElementById('game-status');
            const p2Bg = document.getElementById('p2-indicator-bg');

            if(state.currentPlayer === 1) {
                p1Ind.style.opacity = '1';
                p1Dot.classList.remove('hidden');
                p2Ind.style.opacity = '0.5';
                p2Dot.classList.add('hidden');
                p2Bg.classList.remove('border-emerald-400', 'border-2');
                p2Bg.classList.add('border-transparent');
                status.innerText = "è½®åˆ°æœ±è¿ª (ğŸ°) è½å­...";
                status.className = "text-emerald-400 font-bold text-lg animate-pulse";
            } else {
                p1Ind.style.opacity = '0.5';
                p1Dot.classList.add('hidden');
                p2Ind.style.opacity = '1';
                p2Dot.classList.remove('hidden');
                p2Bg.classList.remove('border-transparent');
                p2Bg.classList.add('border-emerald-400', 'border-2');
                const name = state.mode === 'pve' ? 'ç”µè„‘' : 'å°¼å…‹';
                status.innerText = state.aiThinking ? `${name} æ­£åœ¨æ€è€ƒ...` : `è½®åˆ° ${name} è½å­...`;
                status.className = "text-rose-400 font-bold text-lg animate-pulse";
            }
        }

        function showWinner(winner) {
            state.gameOver = true;
            if(state.timerInterval) clearInterval(state.timerInterval);

            const modal = document.getElementById('result-modal');
            const icon = document.getElementById('winner-icon');
            const text = document.getElementById('winner-text');
            const sub = document.getElementById('winner-sub');

            modal.classList.remove('hidden');

            if(winner === 1) {
                icon.innerText = 'ğŸ°';
                text.innerText = 'æœ±è¿ªèƒœåˆ©ï¼';
                text.className = "text-3xl font-black text-emerald-400";
                sub.innerText = 'è¿™å°±æ˜¯å…”å­çš„æ™ºæ…§ï¼';
            } else if (winner === 2) {
                const isAI = state.mode === 'pve';
                icon.innerText = isAI ? 'ğŸ¤–' : 'ğŸ¦Š';
                text.innerText = isAI ? 'AI èƒœåˆ©ï¼' : 'å°¼å…‹èƒœåˆ©ï¼';
                text.className = "text-3xl font-black text-rose-400";
                sub.innerText = isAI ? 'è¿˜éœ€è¦å¤šåŠ ç»ƒä¹ å“¦ã€‚' : 'ç‹¡çŒ¾çš„ç‹ç‹¸èµ¢äº†ï¼';
            } else {
                icon.innerText = 'ğŸ¤';
                text.innerText = 'å¹³å±€';
                text.className = "text-3xl font-black text-slate-200";
                sub.innerText = 'æ——é¼“ç›¸å½“çš„å¯¹æ‰‹ã€‚';
            }
        }

        function undoMove() {
            if(state.gameOver || state.aiThinking || state.history.length === 0) return;
            
            let steps = 1;
            if(state.mode === 'pve') {
                if(state.currentPlayer === 1 && state.history.length >= 2) steps = 2;
                else if (state.currentPlayer === 2) return; 
            }

            for(let i=0; i<steps; i++) {
                if(state.history.length === 0) break;
                const lastState = state.history.pop();
                restoreBoardState(lastState);
            }
            
            // Clear selection and hints
            selectedSquare = null;
            refreshBoardUI();
            updateTurnIndicator();
        }

        function saveState() {
            const boardCopy = JSON.parse(JSON.stringify(state.board));
            state.history.push({
                board: boardCopy,
                player: state.currentPlayer,
                lastMove: state.lastMove ? {...state.lastMove} : null
            });
        }

        function restoreBoardState(saved) {
            state.board = saved.board;
            state.currentPlayer = saved.player;
            state.lastMove = saved.lastMove;
        }

        function refreshBoardUI() {
            const container = document.getElementById('board-container');
            if(state.gameType === 'gobang') {
                // Completely re-render gobang to clear old pieces
                container.innerHTML = '';
                initGobang(container, false); // false = don't reset state
            } else {
                renderChessBoard(document.querySelector('.chess-board'));
            }
        }

        // --- äº”å­æ£‹é€»è¾‘ ---

        function initGobang(container, resetState = true) {
            if(resetState) {
                state.board = Array(15).fill().map(() => Array(15).fill(0));
            }
            
            const boardEl = document.createElement('div');
            boardEl.className = 'gobang-board';
            
            for(let y=0; y<15; y++) {
                for(let x=0; x<15; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'gobang-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.onclick = () => handleGobangClick(x, y);
                    
                    // Render existing piece if any (for undo/restore)
                    if(state.board[y][x] !== 0) {
                        renderGobangPieceInCell(cell, state.board[y][x], false);
                    }
                    
                    boardEl.appendChild(cell);
                }
            }
            container.appendChild(boardEl);
        }

        function handleGobangClick(x, y) {
            if(state.gameOver || state.board[y][x] !== 0 || state.aiThinking) return;
            
            saveState();

            placeGobangPiece(x, y, state.currentPlayer);

            if(checkGobangWin(x, y, state.currentPlayer)) {
                setTimeout(() => showWinner(state.currentPlayer), 300);
                return;
            }

            state.currentPlayer = state.currentPlayer === 1 ? 2 : 1;
            updateTurnIndicator();

            if(state.mode === 'pve' && state.currentPlayer === 2) {
                state.aiThinking = true;
                updateTurnIndicator();
                setTimeout(aiGobangMove, 500);
            }
        }

        function placeGobangPiece(x, y, player) {
            state.board[y][x] = player;
            state.lastMove = {x, y};
            const cells = document.querySelectorAll('.gobang-cell');
            const cell = cells[y * 15 + x];
            renderGobangPieceInCell(cell, player, true);
        }

        function renderGobangPieceInCell(cell, player, animate) {
            const piece = document.createElement('div');
            piece.className = player === 1 ? 'gobang-piece piece-white' : 'gobang-piece piece-black';
            piece.innerText = player === 1 ? config.icons.p1 : (state.mode === 'pve' ? config.icons.p2_ai : config.icons.p2_human);
            
            // Remove previous last move markers
            document.querySelectorAll('.last-move-marker').forEach(el => el.classList.remove('last-move-marker'));
            piece.classList.add('last-move-marker');

            if(animate) {
                piece.style.transform = 'scale(0)';
                cell.appendChild(piece);
                setTimeout(() => piece.style.transform = 'scale(1)', 50);
            } else {
                cell.appendChild(piece);
            }
        }

        function checkGobangWin(x, y, player) {
            const dirs = [[1,0], [0,1], [1,1], [1,-1]];
            for(let d of dirs) {
                let count = 1;
                for(let i=1; i<5; i++) {
                    let nx = x + d[0]*i, ny = y + d[1]*i;
                    if(nx>=0 && nx<15 && ny>=0 && ny<15 && state.board[ny][nx] === player) count++;
                    else break;
                }
                for(let i=1; i<5; i++) {
                    let nx = x - d[0]*i, ny = y - d[1]*i;
                    if(nx>=0 && nx<15 && ny>=0 && ny<15 && state.board[ny][nx] === player) count++;
                    else break;
                }
                if(count >= 5) return true;
            }
            return false;
        }

        // --- äº”å­æ£‹ AI ---
        function aiGobangMove() {
            saveState();
            let bestMove = null;
            let depth = state.difficulty === 'easy' ? 0 : (state.difficulty === 'medium' ? 1 : 2);
            
            if(state.difficulty === 'easy' && Math.random() < 0.3) {
                const empties = [];
                for(let y=0; y<15; y++) for(let x=0; x<15; x++) if(state.board[y][x]===0) empties.push({x,y});
                bestMove = empties[Math.floor(Math.random() * empties.length)];
            } else {
                bestMove = getBestMoveGobang(state.board, 2, depth);
            }

            placeGobangPiece(bestMove.x, bestMove.y, 2);
            if(checkGobangWin(bestMove.x, bestMove.y, 2)) {
                setTimeout(() => showWinner(2), 300);
            } else {
                state.currentPlayer = 1;
                state.aiThinking = false;
                updateTurnIndicator();
            }
        }

        function getBestMoveGobang(board, player, depth) {
            let candidates = [];
            for(let y=0; y<15; y++) {
                for(let x=0; x<15; x++) {
                    if(board[y][x] !== 0) continue;
                    if(hasNeighbor(board, x, y)) {
                        let score = evaluatePoint(board, x, y, player); 
                        let enemyScore = evaluatePoint(board, x, y, player===1?2:1);
                        let totalScore = score + enemyScore * 0.9; 
                        if (state.difficulty === 'hard') totalScore = score + enemyScore * 1.1;
                        candidates.push({x, y, score: totalScore});
                    }
                }
            }
            if(candidates.length === 0) return {x: 7, y: 7};
            candidates.sort((a,b) => b.score - a.score);
            return candidates[0];
        }

        function hasNeighbor(board, x, y) {
            for(let dy=-1; dy<=1; dy++) {
                for(let dx=-1; dx<=1; dx++) {
                    if(dy===0 && dx===0) continue;
                    let nx=x+dx, ny=y+dy;
                    if(nx>=0 && nx<15 && ny>=0 && ny<15 && board[ny][nx] !== 0) return true;
                }
            }
            return false;
        }

        function evaluatePoint(board, x, y, player) {
            let totalScore = 0;
            const dirs = [[1,0], [0,1], [1,1], [1,-1]];
            board[y][x] = player;
            for(let d of dirs) {
                let line = [];
                for(let i=-4; i<=4; i++) {
                    let nx = x + d[0]*i, ny = y + d[1]*i;
                    if(nx>=0 && nx<15 && ny>=0 && ny<15) line.push(board[ny][nx]);
                    else line.push(-1);
                }
                totalScore += evaluateLine(line, player);
            }
            board[y][x] = 0;
            return totalScore;
        }

        function evaluateLine(line, p) {
            const s = line.map(v => v===p ? 'P' : (v===0 ? '_' : 'O')).join('');
            let score = 0;
            if(s.includes('PPPPP')) score += 100000;
            else if(s.includes('_PPPP_')) score += 10000;
            else if(s.includes('PPPP_') || s.includes('_PPPP')) score += 2500;
            else if(s.includes('_PPP_')) score += 3000;
            else if(s.includes('PPP_') || s.includes('_PPP')) score += 500;
            else if(s.includes('_PP_')) score += 200;
            return score;
        }

        // --- å›½é™…è±¡æ£‹é€»è¾‘ ---
        const CHESS_SYMBOLS = {
            1: 'â™Ÿ', 2: 'â™œ', 3: 'â™', 4: 'â™', 5: 'â™›', 6: 'â™š',
            [-1]: 'â™Ÿ', [-2]: 'â™œ', [-3]: 'â™', [-4]: 'â™', [-5]: 'â™›', [-6]: 'â™š'
        };
        const INITIAL_CHESS = [
            [-2,-3,-4,-5,-6,-4,-3,-2],
            [-1,-1,-1,-1,-1,-1,-1,-1],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [1,1,1,1,1,1,1,1],
            [2,3,4,5,6,4,3,2]
        ];

        let selectedSquare = null;

        function initChess(container) {
            const boardEl = document.createElement('div');
            boardEl.className = 'chess-board';
            state.board = JSON.parse(JSON.stringify(INITIAL_CHESS));
            selectedSquare = null;
            renderChessBoard(boardEl);
            container.appendChild(boardEl);
        }

        function renderChessBoard(boardEl) {
            boardEl.innerHTML = '';
            for(let y=0; y<8; y++) {
                for(let x=0; x<8; x++) {
                    const sq = document.createElement('div');
                    const isWhite = (x + y) % 2 === 0;
                    sq.className = `chess-square ${isWhite ? 'white' : 'black'}`;
                    
                    // Selected highlight
                    if(selectedSquare && selectedSquare.x === x && selectedSquare.y === y) {
                        sq.classList.add('selected');
                    }
                    
                    // Last move highlight
                    if(state.lastMove && ((state.lastMove.fx === x && state.lastMove.fy === y) || (state.lastMove.tx === x && state.lastMove.ty === y))) {
                        sq.classList.add('last-move');
                    }

                    const pieceVal = state.board[y][x];
                    if(pieceVal !== 0) {
                        const piece = document.createElement('div');
                        const isWhiteSide = pieceVal > 0;
                        piece.className = `chess-piece ${isWhiteSide ? 'white-side' : 'black-side'}`;
                        if(Math.abs(pieceVal) === 6) {
                            piece.innerText = isWhiteSide ? 'ğŸ°' : (state.mode === 'pve' ? 'ğŸ¤–' : 'ğŸ¦Š');
                        } else {
                            piece.innerText = CHESS_SYMBOLS[pieceVal];
                        }
                        sq.appendChild(piece);
                    }

                    sq.onclick = () => handleChessClick(x, y);
                    boardEl.appendChild(sq);
                }
            }
            
            // Re-render hints if needed
            if(selectedSquare && state.showHints) {
                renderHints(selectedSquare.x, selectedSquare.y);
            }
        }

        function renderHints(x, y) {
            const boardEl = document.querySelector('.chess-board');
            if(!boardEl) return;
            
            // Clear old hints
            document.querySelectorAll('.hint-dot, .hint-capture').forEach(el => el.remove());

            // Calc moves
            const moves = [];
            for(let ty=0; ty<8; ty++) {
                for(let tx=0; tx<8; tx++) {
                    if(isValidMove(x, y, tx, ty, state.board)) {
                        moves.push({tx, ty});
                    }
                }
            }

            moves.forEach(m => {
                const targetIndex = m.ty * 8 + m.tx;
                const targetSq = boardEl.children[targetIndex];
                
                const hint = document.createElement('div');
                const isCapture = state.board[m.ty][m.tx] !== 0;
                hint.className = isCapture ? 'hint-capture' : 'hint-dot';
                
                targetSq.appendChild(hint);
            });
        }

        function handleChessClick(x, y) {
            if(state.gameOver || state.aiThinking) return;

            const clickedVal = state.board[y][x];
            const isOwnPiece = state.currentPlayer === 1 ? clickedVal > 0 : clickedVal < 0;

            if(isOwnPiece) {
                selectedSquare = {x, y};
                refreshChessUI();
            } else if (selectedSquare) {
                if(isValidMove(selectedSquare.x, selectedSquare.y, x, y, state.board)) {
                    saveState();
                    state.lastMove = {fx: selectedSquare.x, fy: selectedSquare.y, tx: x, ty: y};
                    
                    makeChessMove(selectedSquare.x, selectedSquare.y, x, y);
                    selectedSquare = null;
                    refreshChessUI();
                    
                    if(!hasKing(state.board, state.currentPlayer === 1 ? 2 : 1)) {
                         showWinner(state.currentPlayer);
                         return;
                    }

                    state.currentPlayer = state.currentPlayer === 1 ? 2 : 1;
                    updateTurnIndicator();

                    if(state.mode === 'pve' && state.currentPlayer === 2) {
                        state.aiThinking = true;
                        updateTurnIndicator();
                        setTimeout(aiChessMove, 500);
                    }
                }
            }
        }

        function refreshChessUI() {
            const boardEl = document.querySelector('.chess-board');
            if(boardEl) renderChessBoard(boardEl);
        }

        function makeChessMove(fx, fy, tx, ty) {
            state.board[ty][tx] = state.board[fy][fx];
            state.board[fy][fx] = 0;
            // Promotion
            if(state.board[ty][tx] === 1 && ty === 0) state.board[ty][tx] = 5;
            if(state.board[ty][tx] === -1 && ty === 7) state.board[ty][tx] = -5;
        }

        function hasKing(board, player) {
            const target = player === 1 ? 6 : -6;
            for(let r of board) if(r.includes(target)) return true;
            return false;
        }

        function isValidMove(fx, fy, tx, ty, board) {
            const p = board[fy][fx];
            const target = board[ty][tx];
            const type = Math.abs(p);
            const dx = tx - fx;
            const dy = ty - fy;
            const adx = Math.abs(dx);
            const ady = Math.abs(dy);
            
            if(target !== 0 && ((p>0 && target>0) || (p<0 && target<0))) return false;

            // 1. Pawn
            if(type === 1) {
                const dir = p > 0 ? -1 : 1;
                const startRow = p > 0 ? 6 : 1;
                if(dx === 0 && target === 0) {
                    if(dy === dir) return true;
                    if(fy === startRow && dy === 2*dir && board[fy+dir][fx] === 0) return true;
                }
                if(adx === 1 && dy === dir && target !== 0) return true;
                return false;
            }
            // 2. Rook
            if(type === 2) {
                if(dx !== 0 && dy !== 0) return false;
                return isPathClear(fx, fy, tx, ty, board);
            }
            // 3. Knight
            if(type === 3) return (adx === 1 && ady === 2) || (adx === 2 && ady === 1);
            // 4. Bishop
            if(type === 4) {
                if(adx !== ady) return false;
                return isPathClear(fx, fy, tx, ty, board);
            }
            // 5. Queen
            if(type === 5) {
                if(dx !== 0 && dy !== 0 && adx !== ady) return false;
                return isPathClear(fx, fy, tx, ty, board);
            }
            // 6. King
            if(type === 6) return adx <= 1 && ady <= 1;
            return false;
        }

        function isPathClear(fx, fy, tx, ty, board) {
            const dx = Math.sign(tx - fx);
            const dy = Math.sign(ty - fy);
            let x = fx + dx;
            let y = fy + dy;
            while(x !== tx || y !== ty) {
                if(board[y][x] !== 0) return false;
                x += dx;
                y += dy;
            }
            return true;
        }

        // --- å›½é™…è±¡æ£‹ AI ---
        function aiChessMove() {
            saveState();
            const moves = [];
            for(let y=0; y<8; y++) {
                for(let x=0; x<8; x++) {
                    if(state.board[y][x] < 0) { // AI is Black
                        for(let ty=0; ty<8; ty++) {
                            for(let tx=0; tx<8; tx++) {
                                if(isValidMove(x, y, tx, ty, state.board)) {
                                    moves.push({fx:x, fy:y, tx:tx, ty:ty});
                                }
                            }
                        }
                    }
                }
            }

            if(moves.length === 0) {
                state.aiThinking = false;
                return;
            }
            
            let bestMove = moves[0];
            let bestScore = -9999;
            moves.sort(() => Math.random() - 0.5);

            if(state.difficulty === 'easy') {
                bestMove = moves[0];
            } else {
                for(let m of moves) {
                    let score = 0;
                    const targetVal = Math.abs(state.board[m.ty][m.tx]);
                    if(targetVal === 6) score += 1000;
                    else if(targetVal === 5) score += 90;
                    else if(targetVal === 2) score += 50;
                    else if(targetVal === 4 || targetVal === 3) score += 30;
                    else if(targetVal === 1) score += 10;

                    if(state.difficulty === 'hard') {
                        if(isSquareUnderAttack(m.tx, m.ty, 1, state.board)) {
                            score -= Math.abs(state.board[m.fy][m.fx]) * 5;
                        }
                    }
                    if(score > bestScore) {
                        bestScore = score;
                        bestMove = m;
                    }
                }
            }

            state.lastMove = {fx: bestMove.fx, fy: bestMove.fy, tx: bestMove.tx, ty: bestMove.ty};
            makeChessMove(bestMove.fx, bestMove.fy, bestMove.tx, bestMove.ty);
            refreshChessUI();

            if(!hasKing(state.board, 1)) {
                showWinner(2);
            } else {
                state.currentPlayer = 1;
                state.aiThinking = false;
                updateTurnIndicator();
            }
        }

        function isSquareUnderAttack(tx, ty, attackSide, board) {
            for(let y=0; y<8; y++) {
                for(let x=0; x<8; x++) {
                    const p = board[y][x];
                    if((attackSide === 1 && p > 0) || (attackSide === 2 && p < 0)) {
                        if(isValidMove(x, y, tx, ty, board)) return true;
                    }
                }
            }
            return false;
        }

    </script>
</body>
</html>
